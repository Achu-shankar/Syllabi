from pydantic import BaseModel, Field
from typing import List, Optional
from uuid import UUID
from datetime import datetime

class BoundingBox(BaseModel):
    """
    Represents the bounding box of a text element or chunk on a page.
    Coordinates are typically from the top-left origin.
    Page width and height are included for relative coordinate calculations if needed.
    """
    x0: float = Field(..., description="Left-most x-coordinate of the bounding box.")
    y0: float = Field(..., description="Top-most y-coordinate of the bounding box.")
    x1: float = Field(..., description="Right-most x-coordinate of the bounding box.")
    y1: float = Field(..., description="Bottom-most y-coordinate of the bounding box.")
    page_width: float = Field(..., description="Total width of the page.")
    page_height: float = Field(..., description="Total height of the page.")

class ParsedTextElement(BaseModel):
    """
    Represents a low-level text element extracted by a PDF parser,
    including its text content, bounding box, and original page context.
    """
    text: str = Field(..., description="The text content of the element.")
    x0: float = Field(..., description="Left-most x-coordinate of the element's bounding box.")
    y0: float = Field(..., description="Top-most y-coordinate of the element's bounding box.")
    x1: float = Field(..., description="Right-most x-coordinate of the element's bounding box.")
    y1: float = Field(..., description="Bottom-most y-coordinate of the element's bounding box.")
    
    # Add page context directly to each element
    page_number: int = Field(..., description="The 1-indexed page number this element belongs to.")
    page_width: float = Field(..., description="Total width of the page this element belongs to.")
    page_height: float = Field(..., description="Total height of the page this element belongs to.")

    # Optional: Add other attributes from parser if needed, e.g., fontname, size

class ParsedPage(BaseModel):
    """
    Represents all parsed text elements from a single page of a document,
    along with the page's dimensions.
    """
    page_number: int = Field(..., description="The 1-indexed page number.")
    width: float = Field(..., description="The width of the page.")
    height: float = Field(..., description="The height of the page.")
    elements: List[ParsedTextElement] = Field(default_factory=list, description="List of parsed text elements on the page.")

class ChunkBase(BaseModel):
    """
    Base schema for properties of a document chunk.
    """
    reference_id: UUID = Field(..., description="Identifier of the parent reference document.")
    user_id: UUID = Field(..., description="Identifier of the user associated with the chunk.")
    chatbot_id: UUID = Field(..., description="Identifier of the chatbot associated with the chunk.")
    page_number: int = Field(..., description="The page number in the original document where this chunk originated.")
    chunk_text: str = Field(..., description="The actual text content of the chunk. This is the text that will be embedded.")
    token_count: int = Field(..., description="Number of tokens in chunk_text, relevant to the embedding model used.")
    
    # Replaced single bounding_box with a list of constituent elements
    constituent_elements: List[ParsedTextElement] = Field(..., description="List of original parsed text elements (with their individual coordinates and text) that make up this chunk.")
    
    parser_metadata: Optional[dict] = Field(None, description="Optional parser-specific metadata.")

class ChunkCreate(ChunkBase):
    """
    Schema for creating a new chunk before it's stored in the database.
    Does not include fields generated by the database (like chunk_id or created_at)
    or the embedding itself, which is handled separately before DB insertion.
    """
    pass # Inherits all fields from ChunkBase, no new fields needed for creation payload

# ============================================================================
# MULTIMEDIA CHUNK SCHEMAS
# ============================================================================

class MultimediaChunkBase(BaseModel):
    """
    Base schema for multimedia chunks (video/audio content).
    """
    reference_id: UUID = Field(..., description="Identifier of the parent reference document.")
    user_id: UUID = Field(..., description="Identifier of the user associated with the chunk.")
    chatbot_id: UUID = Field(..., description="Identifier of the chatbot associated with the chunk.")
    chunk_text: str = Field(..., description="The transcript text content of the chunk.")
    token_count: int = Field(..., description="Number of tokens in chunk_text.")
    
    # Multimedia-specific fields
    content_type: str = Field(..., description="Type of content: video or audio")
    start_time_seconds: int = Field(..., description="Start timestamp in seconds from beginning")
    end_time_seconds: int = Field(..., description="End timestamp in seconds from beginning")
    speaker: Optional[str] = Field(None, description="Speaker name if available")
    confidence_score: Optional[float] = Field(None, description="Transcription confidence score (0.0 to 1.0)")
    chunk_type: str = Field(..., description="Type of chunk: transcript, audio_segment, etc.")
    
    # Store multimedia-specific metadata
    multimedia_metadata: Optional[dict] = Field(None, description="Multimedia-specific metadata (segments, words, etc.)")

class MultimediaChunkCreate(MultimediaChunkBase):
    """
    Schema for creating multimedia chunks before database storage.
    """
    pass

class MultimediaChunk(MultimediaChunkBase):
    """
    Schema representing a multimedia chunk as stored in the database.
    """
    chunk_id: UUID = Field(..., description="Unique identifier for the multimedia chunk.")
    created_at: datetime = Field(..., description="Timestamp of when the chunk was created.")
    
    class Config:
        from_attributes = True

class Chunk(ChunkBase):
    """
    Schema representing a document chunk as stored in the database and returned via API.
    """
    id: UUID = Field(..., description="Unique identifier for the text chunk.")
    # The 'embedding' field is intentionally omitted here.
    # It's large and usually only needed for specific DB operations or similarity search.
    # If you need to return it via API, you can add:
    # embedding: Optional[List[float]] = Field(None, description="Vector embedding of the chunk_text.")
    created_at: datetime = Field(..., description="Timestamp of when the chunk was created.")

    class Config:
        from_attributes = True # For Pydantic V2, formerly orm_mode = True
        # Ensure this is 'from_attributes' for Pydantic V2
        # For Pydantic V1, it would be:
        # orm_mode = True

# Example usage (not part of the file, just for illustration):
# if __name__ == "__main__":
#     sample_bbox = BoundingBox(x0=10.0, y0=10.0, x1=50.0, y1=20.0, page_width=600.0, page_height=800.0)
#     print(sample_bbox.model_dump_json(indent=2))

#     sample_chunk_create = ChunkCreate(
#         reference_id=UUID("d290f1ee-6c54-4b01-90e6-d701748f0851"),
#         user_id="user_abc_123",
#         project_id=UUID("08042149-675b-4e3e-a7f2-3a83737d2e2c"),
#         page_number=1,
#         chunk_text="This is a sample chunk of text.",
#         token_count=8,
#         constituent_elements=[sample_bbox]
#     )
#     print(sample_chunk_create.model_dump_json(indent=2)) 